# Generated by Grammarinator 19.3+53.gbfde275.d20201030

import random
from math import inf
from grammarinator.runtime import *
from CypherGenerator import CypherGenerator

nodes = []
edges = []
paths = []
aliases = []


def in_node_type(current_node, name):
    while current_node is not None:
        if current_node.name == name:
            return True
        return in_node_type(current_node.parent, name)
    return False


def variable_name(basename):
    global nodes
    global edges
    global paths
    global aliases
    probability_of_new = 0.5
    # Select the appropriate global array
    arr = []
    if basename == "node":
        arr = nodes
    elif basename == "edge":
        arr = edges
    elif basename == "path":
        arr = paths
    elif basename == "alias":
        arr = aliases
        probability_of_new = 1

    entity_count = len(arr)
    name = ""
    if entity_count == 0 or random.random() < probability_of_new:
        # Create a new entity
        name = "%s_%d" % (basename, entity_count)
        arr.append(name)
    else:
        # Reuse an existing entity
        num = random.randint(0, entity_count - 1)
        name = "%s_%d" % (basename, num)
        arr.append(name)
    return name


def clear_globals():
    clear_non_alias_globals()
    global aliases
    aliases = []


def clear_non_alias_globals():
    global nodes
    global edges
    global paths
    nodes = []
    edges = []
    paths = []


def random_variable():
    probabilities = {}
    if len(nodes) > 0:
        probabilities[random.random()] = nodes
    if len(edges) > 0:
        probabilities[random.random()] = edges
    if len(aliases) > 0:
        probabilities[random.random()] = aliases
    if len(paths) > 0:
        probabilities[random.uniform(0, 0.5)] = paths

    if len(probabilities) == 0:
        return "missing_variable"

    max_key = max(probabilities, key=float)
    arr = probabilities[max_key]

    entity_idx = random.randint(0, len(arr) - 1)
    return arr[entity_idx]


class CustomCypherGenerator(CypherGenerator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.union_all = None
        clear_globals()

    def oC_Union(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Union', parent=parent)) as current:
            with AlternationContext(self, [7, 7], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0 and (self.union_all is None or self.union_all is True):
                    self.union_all = True
                    self.UNION(parent=current)
                    self.SP(parent=current)
                    self.ALL(parent=current)
                    self.SP(parent=current)
                    self.oC_SingleQuery(parent=current)
                elif choice0 == 1 and (self.union_all is None or self.union_all is False):
                    self.union_all = False
                    self.UNION(parent=current)
                    self.SP(parent=current)
                    self.oC_SingleQuery(parent=current)
            return current
    oC_Union.min_depth = 7

    def oC_RelationshipPattern(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RelationshipPattern', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1, 1], [1, 1, 1, 1]) as weights0:
                # If we're in an updating context, we must have exactly one reltype and one direction.
                in_update = in_node_type(parent, 'oC_UpdatingClause') or in_node_type(parent, 'oC_UpdatingStartClause')
                if in_update:
                    ltr = random.randint(0, 1)
                    if ltr:
                        self.oC_LeftArrowHead(parent=current)
                        self.oC_Dash(parent=current)
                        tmp = self._max_depth
                        if self._max_depth < 1:
                            self._max_depth = 1
                        self.oC_RelationshipDetail(parent=current)
                        self._max_depth = tmp
                        self.oC_Dash(parent=current)
                    else:
                        self.oC_Dash(parent=current)
                        tmp = self._max_depth
                        if self._max_depth < 1:
                            self._max_depth = 1
                        self.oC_RelationshipDetail(parent=current)
                        self._max_depth = tmp
                        self.oC_Dash(parent=current)
                        self.oC_RightArrowHead(parent=current)
                else:
                    choice0 = self._model.choice(current, 0, weights0)
                    if choice0 == 0:
                        self.oC_LeftArrowHead(parent=current)
                        self.oC_Dash(parent=current)
                        if self._max_depth >= 1:
                            for _ in self._model.quantify(current, 0, min=0, max=1):
                                self.oC_RelationshipDetail(parent=current)
                        self.oC_Dash(parent=current)
                        self.oC_RightArrowHead(parent=current)
                    elif choice0 == 1:
                        self.oC_LeftArrowHead(parent=current)
                        self.oC_Dash(parent=current)
                        if self._max_depth >= 1:
                            for _ in self._model.quantify(current, 1, min=0, max=1):
                                self.oC_RelationshipDetail(parent=current)
                        self.oC_Dash(parent=current)
                    elif choice0 == 2:
                        self.oC_Dash(parent=current)
                        if self._max_depth >= 1:
                            for _ in self._model.quantify(current, 2, min=0, max=1):
                                self.oC_RelationshipDetail(parent=current)
                        self.oC_Dash(parent=current)
                        self.oC_RightArrowHead(parent=current)
                    elif choice0 == 3:
                        self.oC_Dash(parent=current)
                        if self._max_depth >= 1:
                            for _ in self._model.quantify(current, 3, min=0, max=1):
                                self.oC_RelationshipDetail(parent=current)
                        self.oC_Dash(parent=current)
            return current
    oC_RelationshipPattern.min_depth = 1

    def oC_RelationshipDetail(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RelationshipDetail', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            
            variable_length_traversal = False
            in_update = in_node_type(parent, 'oC_UpdatingClause') or in_node_type(parent, 'oC_UpdatingStartClause')
            if in_update:
                tmp = self._max_depth
                self._max_depth = 3
                self.oC_RelationshipTypes(parent=current)
                self._max_depth = tmp
            else:
                if self._max_depth >= 4:
                    for _ in self._model.quantify(current, 0, min=0, max=1):
                        self.oC_Variable(parent=current)
                if self._max_depth >= 3:
                    for _ in self._model.quantify(current, 1, min=0, max=1):
                        self.oC_RelationshipTypes(parent=current)
                if self._max_depth >= 1:
                    for _ in self._model.quantify(current, 2, min=0, max=1):
                        self.oC_RangeLiteral(parent=current)
                        variable_length_traversal = True
                if self._max_depth >= 2:
                    if not variable_length_traversal:
                        for _ in self._model.quantify(current, 3, min=0, max=1):
                            self.oC_Properties(parent=current)
            UnlexerRule(src=']', parent=current)
            return current
    oC_RelationshipDetail.min_depth = 0

    def oC_RelationshipTypes(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RelationshipTypes', parent=parent)) as current:
            UnlexerRule(src=':', parent=current)
            self.oC_RelTypeName(parent=current)
            if not (in_node_type(parent, 'oC_UpdatingClause') or in_node_type(parent, 'oC_UpdatingStartClause')) and self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src='|', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            UnlexerRule(src=':', parent=current)
                    self.oC_RelTypeName(parent=current)
            return current
    oC_RelationshipTypes.min_depth = 2

    def EscapedSymbolicName_0(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EscapedSymbolicName_0', parent=parent)) as current:
            UnlexerRule(src='var', parent=current)
            variable = "var"
            if in_node_type(parent, 'oC_NodePattern'):
                variable = variable_name("node")
            elif in_node_type(parent, 'oC_RelationshipDetail'):
                variable = variable_name("edge")
            elif in_node_type(parent, 'oC_IdInColl'):
                variable = "comprehension_var"
            elif in_node_type(parent, 'oC_PatternComprehension'):
                variable = "pattern_comprehension_var"
            elif in_node_type(parent, 'oC_Atom'):
                variable = random_variable()
            elif in_node_type(parent, 'oC_PropertyExpression'):
                variable = random_variable()
            elif in_node_type(parent, 'oC_PatternPart'):
                variable = variable_name("path")
            elif in_node_type(parent, 'oC_Unwind'):
                variable = "unwind_var"
            elif in_node_type(parent, 'oC_SetItem'):
                variable = random_variable()
            elif in_node_type(parent, 'oC_Delete'):
                variable = random_variable()
            elif in_node_type(parent, 'oC_YieldItem'):
                variable = "yield"
            elif in_node_type(parent, 'oC_ProjectionItem'):
                variable = variable_name("alias")
            else:
                variable = "UNREACHABLE?"
            # Pass the newly-set variable name to the unlexer.
            UnlexerRule(src=variable, parent=current)
            return current
    EscapedSymbolicName_0.min_depth = 0

    def oC_FunctionInvocation(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_FunctionInvocation', parent=parent)) as current:
            function_name = "RAND" # TODO tmp
            UnlexerRule(src=function_name, parent=current)
            UnlexerRule(src='(', parent=current)
            # if self._max_depth >= 3:
            #     for _ in self._model.quantify(current, 0, min=0, max=1):
            #         self.DISTINCT(parent=current)
            #         self.SP(parent=current)
            # if self._max_depth >= 4:
            #     for _ in self._model.quantify(current, 1, min=0, max=1):
            #         self.rG_Expression(parent=current)
            #         self.SP(parent=current)
            #         if self._max_depth >= 4:
            #             for _ in self._model.quantify(current, 2, min=0, max=inf):
            #                 UnlexerRule(src=',', parent=current)
            #                 self.SP(parent=current)
            #                 self.rG_Expression(parent=current)
            #                 self.SP(parent=current)
            UnlexerRule(src=')', parent=current)
            return current
    oC_FunctionInvocation.min_depth = 4

    def oC_With(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_With', parent=parent)) as current:
            self.WITH(parent=current)
            self.oC_ProjectionBody(parent=current)
            if self._max_depth >= 16:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Where(parent=current)
            
            clear_non_alias_globals()
            
            return current
    oC_With.min_depth = 4

    def oC_ProjectionItems(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ProjectionItems', parent=parent)) as current:
            with AlternationContext(self, [0, 5], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                in_with = in_node_type(parent, 'oC_With') # Alias all WITH projections
                if in_with:
                    choice0 = 1
                if choice0 == 0:
                    UnlexerRule(src='*', parent=current)
                    if self._max_depth >= 5:
                        for _ in self._model.quantify(current, 0, min=0, max=inf):
                            self.SP(parent=current)
                            UnlexerRule(src=',', parent=current)
                            self.SP(parent=current)
                            self.oC_ProjectionItem(parent=current)
                elif choice0 == 1:
                    self.oC_ProjectionItem(parent=current)
                    if self._max_depth >= 5:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            self.SP(parent=current)
                            UnlexerRule(src=',', parent=current)
                            self.SP(parent=current)
                            self.oC_ProjectionItem(parent=current)
            return current
    oC_ProjectionItems.min_depth = 0

    def oC_ProjectionItem(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ProjectionItem', parent=parent)) as current:
            with AlternationContext(self, [4, 4], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                in_with = in_node_type(parent, 'oC_With') # Alias all WITH projections
                if in_with:
                    choice0 = 0
                if choice0 == 0:
                    self.rG_Expression(parent=current)
                    self.SP(parent=current)
                    self.AS(parent=current)
                    self.SP(parent=current)
                    self.oC_Variable(parent=current)
                elif choice0 == 1:
                    self.rG_Expression(parent=current)
            return current
    oC_ProjectionItem.min_depth = 4
