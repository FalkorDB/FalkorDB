# Generated by Grammarinator 23.7

import itertools

from math import inf
from grammarinator.runtime import *

class CypherGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def oC_Cypher(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Cypher', parent=parent)) as current:
            self.SP(parent=current)
            self.oC_Statement(parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    UnlexerRule(src=';', parent=current)
            self.SP(parent=current)
            self.EOF(parent=current)
            return current
    oC_Cypher.min_depth = 10

    def oC_Statement(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Statement', parent=parent)) as current:
            self.oC_Query(parent=current)
            return current
    oC_Statement.min_depth = 9

    def oC_Query(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Query', parent=parent)) as current:
            self.oC_RegularQuery(parent=current)
            return current
    oC_Query.min_depth = 8

    def oC_RegularQuery(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RegularQuery', parent=parent)) as current:
            self.oC_SingleQuery(parent=current)
            if self._max_depth >= 8:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    self.oC_Union(parent=current)
            return current
    oC_RegularQuery.min_depth = 7

    def oC_Union(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Union', parent=parent)) as current:
            with AlternationContext(self, [7, 7], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.UNION(parent=current)
                    self.SP(parent=current)
                    self.ALL(parent=current)
                    self.SP(parent=current)
                    self.oC_SingleQuery(parent=current)
                elif choice0 == 1:
                    self.UNION(parent=current)
                    self.SP(parent=current)
                    self.oC_SingleQuery(parent=current)
            return current
    oC_Union.min_depth = 7

    def UNION(self, parent=None):
        with RuleContext(self, UnlexerRule(name='UNION', parent=parent)) as current:
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='N', parent=current)
            return current
    UNION.min_depth = 0

    def ALL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ALL', parent=parent)) as current:
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='L', parent=current)
            return current
    ALL.min_depth = 0

    def oC_SingleQuery(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_SingleQuery', parent=parent)) as current:
            with AlternationContext(self, [6, 7], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.oC_SinglePartQuery, self.oC_MultiPartQuery][choice0](parent=current)
            return current
    oC_SingleQuery.min_depth = 6

    def oC_SinglePartQuery(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_SinglePartQuery', parent=parent)) as current:
            with AlternationContext(self, [5, 6], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    if self._max_depth >= 6:
                        for _ in self._model.quantify(current, 0, min=0, max=inf):
                            self.oC_ReadingClause(parent=current)
                            self.SP(parent=current)
                    self.oC_Return(parent=current)
                elif choice0 == 1:
                    if self._max_depth >= 6:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            self.oC_ReadingClause(parent=current)
                            self.SP(parent=current)
                    self.oC_UpdatingClause(parent=current)
                    if self._max_depth >= 6:
                        for _ in self._model.quantify(current, 2, min=0, max=inf):
                            self.SP(parent=current)
                            self.oC_UpdatingClause(parent=current)
                    if self._max_depth >= 5:
                        for _ in self._model.quantify(current, 3, min=0, max=1):
                            self.SP(parent=current)
                            self.oC_Return(parent=current)
            return current
    oC_SinglePartQuery.min_depth = 5

    def oC_MultiPartQuery(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_MultiPartQuery', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    if self._max_depth >= 6:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            self.oC_ReadingClause(parent=current)
                            self.SP(parent=current)
                    if self._max_depth >= 6:
                        for _ in self._model.quantify(current, 2, min=0, max=inf):
                            self.oC_UpdatingClause(parent=current)
                            self.SP(parent=current)
                    self.oC_With(parent=current)
                    self.SP(parent=current)
            self.oC_SinglePartQuery(parent=current)
            return current
    oC_MultiPartQuery.min_depth = 6

    def oC_UpdatingClause(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_UpdatingClause', parent=parent)) as current:
            with AlternationContext(self, [6, 5, 5, 6], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.oC_Create, self.oC_Merge, self.oC_Delete, self.oC_Set][choice0](parent=current)
            return current
    oC_UpdatingClause.min_depth = 5

    def oC_ReadingClause(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ReadingClause', parent=parent)) as current:
            with AlternationContext(self, [6, 5, 5], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.oC_Match, self.oC_Unwind, self.oC_InQueryCall][choice0](parent=current)
            return current
    oC_ReadingClause.min_depth = 5

    def oC_Match(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Match', parent=parent)) as current:
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.OPTIONAL(parent=current)
                    self.SP(parent=current)
            self.MATCH(parent=current)
            self.SP(parent=current)
            self.oC_Pattern(parent=current)
            if self._max_depth >= 16:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Where(parent=current)
            return current
    oC_Match.min_depth = 5

    def OPTIONAL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='OPTIONAL', parent=parent)) as current:
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='P', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='L', parent=current)
            return current
    OPTIONAL.min_depth = 0

    def MATCH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='MATCH', parent=parent)) as current:
            UnlexerRule(src='M', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='H', parent=current)
            return current
    MATCH.min_depth = 0

    def oC_Unwind(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Unwind', parent=parent)) as current:
            self.UNWIND(parent=current)
            self.SP(parent=current)
            self.rG_Expression(parent=current)
            self.SP(parent=current)
            self.AS(parent=current)
            self.SP(parent=current)
            self.oC_Variable(parent=current)
            return current
    oC_Unwind.min_depth = 4

    def UNWIND(self, parent=None):
        with RuleContext(self, UnlexerRule(name='UNWIND', parent=parent)) as current:
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='W', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='D', parent=current)
            return current
    UNWIND.min_depth = 0

    def AS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='AS', parent=parent)) as current:
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='S', parent=current)
            return current
    AS.min_depth = 0

    def oC_Merge(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Merge', parent=parent)) as current:
            self.MERGE(parent=current)
            self.SP(parent=current)
            self.oC_PatternPart(parent=current)
            if self._max_depth >= 7:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    self.oC_MergeAction(parent=current)
            return current
    oC_Merge.min_depth = 4

    def MERGE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='MERGE', parent=parent)) as current:
            UnlexerRule(src='M', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='G', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    MERGE.min_depth = 0

    def oC_MergeAction(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_MergeAction', parent=parent)) as current:
            with AlternationContext(self, [6, 6], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.ON(parent=current)
                    self.SP(parent=current)
                    self.MATCH(parent=current)
                    self.SP(parent=current)
                    self.oC_Set(parent=current)
                elif choice0 == 1:
                    self.ON(parent=current)
                    self.SP(parent=current)
                    self.CREATE(parent=current)
                    self.SP(parent=current)
                    self.oC_Set(parent=current)
            return current
    oC_MergeAction.min_depth = 6

    def ON(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ON', parent=parent)) as current:
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='N', parent=current)
            return current
    ON.min_depth = 0

    def CREATE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CREATE', parent=parent)) as current:
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    CREATE.min_depth = 0

    def oC_Create(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Create', parent=parent)) as current:
            self.CREATE(parent=current)
            self.SP(parent=current)
            self.oC_Pattern(parent=current)
            return current
    oC_Create.min_depth = 5

    def oC_Set(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Set', parent=parent)) as current:
            self.SET(parent=current)
            self.SP(parent=current)
            self.oC_SetItem(parent=current)
            if self._max_depth >= 5:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.oC_SetItem(parent=current)
            return current
    oC_Set.min_depth = 5

    def SET(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SET', parent=parent)) as current:
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='T', parent=current)
            return current
    SET.min_depth = 0

    def oC_SetItem(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_SetItem', parent=parent)) as current:
            with AlternationContext(self, [5, 4, 4], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.oC_PropertyExpression(parent=current)
                    self.SP(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.SP(parent=current)
                    self.rG_Expression(parent=current)
                elif choice0 == 1:
                    self.oC_Variable(parent=current)
                    self.SP(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.SP(parent=current)
                    self.rG_Expression(parent=current)
                elif choice0 == 2:
                    self.oC_Variable(parent=current)
                    self.SP(parent=current)
                    UnlexerRule(src='+=', parent=current)
                    self.SP(parent=current)
                    self.rG_Expression(parent=current)
            return current
    oC_SetItem.min_depth = 4

    def oC_Delete(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Delete', parent=parent)) as current:
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.DETACH(parent=current)
                    self.SP(parent=current)
            self.DELETE(parent=current)
            self.SP(parent=current)
            self.oC_Variable(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 1, min=0, max=inf):
                    self.SP(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.SP(parent=current)
                    self.oC_Variable(parent=current)
            return current
    oC_Delete.min_depth = 4

    def DETACH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DETACH', parent=parent)) as current:
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='H', parent=current)
            return current
    DETACH.min_depth = 0

    def DELETE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DELETE', parent=parent)) as current:
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    DELETE.min_depth = 0

    def oC_InQueryCall(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_InQueryCall', parent=parent)) as current:
            self.CALL(parent=current)
            self.SP(parent=current)
            self.oC_ExplicitProcedureInvocation(parent=current)
            if self._max_depth >= 6:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    self.YIELD(parent=current)
                    self.SP(parent=current)
                    self.oC_YieldItems(parent=current)
            return current
    oC_InQueryCall.min_depth = 4

    def CALL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CALL', parent=parent)) as current:
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='L', parent=current)
            return current
    CALL.min_depth = 0

    def YIELD(self, parent=None):
        with RuleContext(self, UnlexerRule(name='YIELD', parent=parent)) as current:
            UnlexerRule(src='Y', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='D', parent=current)
            return current
    YIELD.min_depth = 0

    def oC_StandaloneCall(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_StandaloneCall', parent=parent)) as current:
            self.CALL(parent=current)
            self.SP(parent=current)
            with AlternationContext(self, [4, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.oC_ExplicitProcedureInvocation, self.oC_ImplicitProcedureInvocation][choice0](parent=current)
            if self._max_depth >= 6:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    self.YIELD(parent=current)
                    self.SP(parent=current)
                    self.oC_YieldItems(parent=current)
            return current
    oC_StandaloneCall.min_depth = 3

    def oC_YieldItems(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_YieldItems', parent=parent)) as current:
            self.oC_YieldItem(parent=current)
            if self._max_depth >= 5:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.SP(parent=current)
                    self.oC_YieldItem(parent=current)
            if self._max_depth >= 16:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Where(parent=current)
            return current
    oC_YieldItems.min_depth = 5

    def oC_YieldItem(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_YieldItem', parent=parent)) as current:
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.oC_ProcedureResultField(parent=current)
                    self.SP(parent=current)
                    self.AS(parent=current)
                    self.SP(parent=current)
            self.oC_Variable(parent=current)
            return current
    oC_YieldItem.min_depth = 4

    def oC_With(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_With', parent=parent)) as current:
            self.WITH(parent=current)
            self.oC_ProjectionBody(parent=current)
            if self._max_depth >= 16:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Where(parent=current)
            return current
    oC_With.min_depth = 4

    def WITH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WITH', parent=parent)) as current:
            UnlexerRule(src='W', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='H', parent=current)
            return current
    WITH.min_depth = 0

    def oC_Return(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Return', parent=parent)) as current:
            self.RETURN(parent=current)
            self.oC_ProjectionBody(parent=current)
            return current
    oC_Return.min_depth = 4

    def RETURN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RETURN', parent=parent)) as current:
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='N', parent=current)
            return current
    RETURN.min_depth = 0

    def oC_ProjectionBody(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ProjectionBody', parent=parent)) as current:
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    self.DISTINCT(parent=current)
            self.SP(parent=current)
            self.oC_ProjectionItems(parent=current)
            if self._max_depth >= 6:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Order(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 2, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Skip(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 3, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Limit(parent=current)
            return current
    oC_ProjectionBody.min_depth = 3

    def DISTINCT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DISTINCT', parent=parent)) as current:
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='T', parent=current)
            return current
    DISTINCT.min_depth = 0

    def oC_ProjectionItems(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ProjectionItems', parent=parent)) as current:
            with AlternationContext(self, [0, 5], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='*', parent=current)
                    if self._max_depth >= 5:
                        for _ in self._model.quantify(current, 0, min=0, max=inf):
                            self.SP(parent=current)
                            UnlexerRule(src=',', parent=current)
                            self.SP(parent=current)
                            self.oC_ProjectionItem(parent=current)
                elif choice0 == 1:
                    self.oC_ProjectionItem(parent=current)
                    if self._max_depth >= 5:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            self.SP(parent=current)
                            UnlexerRule(src=',', parent=current)
                            self.SP(parent=current)
                            self.oC_ProjectionItem(parent=current)
            return current
    oC_ProjectionItems.min_depth = 0

    def oC_ProjectionItem(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ProjectionItem', parent=parent)) as current:
            with AlternationContext(self, [4, 4], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.rG_Expression(parent=current)
                    self.SP(parent=current)
                    self.AS(parent=current)
                    self.SP(parent=current)
                    self.oC_Variable(parent=current)
                elif choice0 == 1:
                    self.rG_Expression(parent=current)
            return current
    oC_ProjectionItem.min_depth = 4

    def oC_Order(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Order', parent=parent)) as current:
            self.ORDER(parent=current)
            self.SP(parent=current)
            self.BY(parent=current)
            self.SP(parent=current)
            self.oC_SortItem(parent=current)
            if self._max_depth >= 5:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=',', parent=current)
                    self.SP(parent=current)
                    self.oC_SortItem(parent=current)
            return current
    oC_Order.min_depth = 5

    def ORDER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ORDER', parent=parent)) as current:
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='R', parent=current)
            return current
    ORDER.min_depth = 0

    def BY(self, parent=None):
        with RuleContext(self, UnlexerRule(name='BY', parent=parent)) as current:
            UnlexerRule(src='B', parent=current)
            UnlexerRule(src='Y', parent=current)
            return current
    BY.min_depth = 0

    def oC_Skip(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Skip', parent=parent)) as current:
            self.L_SKIP(parent=current)
            self.SP(parent=current)
            self.DecimalInteger(parent=current)
            return current
    oC_Skip.min_depth = 3

    def L_SKIP(self, parent=None):
        with RuleContext(self, UnlexerRule(name='L_SKIP', parent=parent)) as current:
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='K', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='P', parent=current)
            return current
    L_SKIP.min_depth = 0

    def oC_Limit(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Limit', parent=parent)) as current:
            self.LIMIT(parent=current)
            self.SP(parent=current)
            self.DecimalInteger(parent=current)
            return current
    oC_Limit.min_depth = 3

    def LIMIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LIMIT', parent=parent)) as current:
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='M', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='T', parent=current)
            return current
    LIMIT.min_depth = 0

    def oC_SortItem(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_SortItem', parent=parent)) as current:
            self.rG_Expression(parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    with AlternationContext(self, [1, 1, 1, 1], [1, 1, 1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        [self.ASCENDING, self.ASC, self.DESCENDING, self.DESC][choice0](parent=current)
            return current
    oC_SortItem.min_depth = 4

    def ASCENDING(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ASCENDING', parent=parent)) as current:
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='G', parent=current)
            return current
    ASCENDING.min_depth = 0

    def ASC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ASC', parent=parent)) as current:
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='C', parent=current)
            return current
    ASC.min_depth = 0

    def DESCENDING(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DESCENDING', parent=parent)) as current:
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='G', parent=current)
            return current
    DESCENDING.min_depth = 0

    def DESC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DESC', parent=parent)) as current:
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='C', parent=current)
            return current
    DESC.min_depth = 0

    def oC_Where(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Where', parent=parent)) as current:
            self.WHERE(parent=current)
            self.SP(parent=current)
            self.oC_Expression(parent=current)
            return current
    oC_Where.min_depth = 15

    def WHERE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WHERE', parent=parent)) as current:
            UnlexerRule(src='W', parent=current)
            UnlexerRule(src='H', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    WHERE.min_depth = 0

    def oC_Pattern(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Pattern', parent=parent)) as current:
            self.oC_PatternPart(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    UnlexerRule(src=',', parent=current)
                    self.SP(parent=current)
                    self.oC_PatternPart(parent=current)
            return current
    oC_Pattern.min_depth = 4

    def oC_PatternPart(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PatternPart', parent=parent)) as current:
            with AlternationContext(self, [4, 3], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.oC_Variable(parent=current)
                    self.SP(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.SP(parent=current)
                    self.oC_AnonymousPatternPart(parent=current)
                elif choice0 == 1:
                    self.oC_AnonymousPatternPart(parent=current)
            return current
    oC_PatternPart.min_depth = 3

    def oC_AnonymousPatternPart(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_AnonymousPatternPart', parent=parent)) as current:
            self.oC_PatternElement(parent=current)
            return current
    oC_AnonymousPatternPart.min_depth = 2

    def oC_PatternElement(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PatternElement', parent=parent)) as current:
            with AlternationContext(self, [1, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.oC_NodePattern(parent=current)
                    if self._max_depth >= 3:
                        for _ in self._model.quantify(current, 0, min=0, max=inf):
                            if self._max_depth >= 3:
                                for _ in self._model.quantify(current, 1, min=0, max=1):
                                    self.SP(parent=current)
                            self.oC_PatternElementChain(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='(', parent=current)
                    self.oC_PatternElement(parent=current)
                    UnlexerRule(src=')', parent=current)
            return current
    oC_PatternElement.min_depth = 1

    def oC_NodePattern(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_NodePattern', parent=parent)) as current:
            UnlexerRule(src='(', parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.oC_Variable(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.oC_NodeLabels(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 2, min=0, max=1):
                    self.oC_Properties(parent=current)
            UnlexerRule(src=')', parent=current)
            return current
    oC_NodePattern.min_depth = 0

    def oC_PatternElementChain(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PatternElementChain', parent=parent)) as current:
            self.oC_RelationshipPattern(parent=current)
            self.oC_NodePattern(parent=current)
            return current
    oC_PatternElementChain.min_depth = 2

    def oC_RelationshipPattern(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RelationshipPattern', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1, 1], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.oC_LeftArrowHead(parent=current)
                    self.oC_Dash(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            self.oC_RelationshipDetail(parent=current)
                    self.oC_Dash(parent=current)
                    self.oC_RightArrowHead(parent=current)
                elif choice0 == 1:
                    self.oC_LeftArrowHead(parent=current)
                    self.oC_Dash(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            self.oC_RelationshipDetail(parent=current)
                    self.oC_Dash(parent=current)
                elif choice0 == 2:
                    self.oC_Dash(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 2, min=0, max=1):
                            self.oC_RelationshipDetail(parent=current)
                    self.oC_Dash(parent=current)
                    self.oC_RightArrowHead(parent=current)
                elif choice0 == 3:
                    self.oC_Dash(parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 3, min=0, max=1):
                            self.oC_RelationshipDetail(parent=current)
                    self.oC_Dash(parent=current)
            return current
    oC_RelationshipPattern.min_depth = 1

    def oC_RelationshipDetail(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RelationshipDetail', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.oC_Variable(parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.oC_RelationshipTypes(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 2, min=0, max=1):
                    self.oC_RangeLiteral(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 3, min=0, max=1):
                    self.oC_Properties(parent=current)
            UnlexerRule(src=']', parent=current)
            return current
    oC_RelationshipDetail.min_depth = 0

    def oC_Properties(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Properties', parent=parent)) as current:
            self.oC_MapLiteral(parent=current)
            return current
    oC_Properties.min_depth = 1

    def oC_RelationshipTypes(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RelationshipTypes', parent=parent)) as current:
            UnlexerRule(src=':', parent=current)
            self.oC_RelTypeName(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src='|', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            UnlexerRule(src=':', parent=current)
                    self.oC_RelTypeName(parent=current)
            return current
    oC_RelationshipTypes.min_depth = 2

    def oC_NodeLabels(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_NodeLabels', parent=parent)) as current:
            self.oC_NodeLabel(parent=current)
            return current
    oC_NodeLabels.min_depth = 3

    def oC_NodeLabel(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_NodeLabel', parent=parent)) as current:
            UnlexerRule(src=':', parent=current)
            self.oC_LabelName(parent=current)
            return current
    oC_NodeLabel.min_depth = 2

    def oC_RangeLiteral(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RangeLiteral', parent=parent)) as current:
            UnlexerRule(src='*', parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.DecimalInteger(parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src='..', parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 2, min=0, max=1):
                            self.DecimalInteger(parent=current)
            return current
    oC_RangeLiteral.min_depth = 0

    def oC_LabelName(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_LabelName', parent=parent)) as current:
            UnlexerRule(src='label', parent=current)
            self.NonZeroDigit(parent=current)
            return current
    oC_LabelName.min_depth = 1

    def oC_RelTypeName(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RelTypeName', parent=parent)) as current:
            UnlexerRule(src='reltype', parent=current)
            self.NonZeroDigit(parent=current)
            return current
    oC_RelTypeName.min_depth = 1

    def rG_Expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='rG_Expression', parent=parent)) as current:
            with AlternationContext(self, [3, 5], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.oC_Atom, self.oC_PropertyExpression][choice0](parent=current)
            return current
    rG_Expression.min_depth = 3

    def oC_Expression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Expression', parent=parent)) as current:
            self.oC_OrExpression(parent=current)
            return current
    oC_Expression.min_depth = 14

    def oC_OrExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_OrExpression', parent=parent)) as current:
            self.oC_XorExpression(parent=current)
            if self._max_depth >= 13:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    self.OR(parent=current)
                    self.SP(parent=current)
                    self.oC_XorExpression(parent=current)
            return current
    oC_OrExpression.min_depth = 13

    def OR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='OR', parent=parent)) as current:
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='R', parent=current)
            return current
    OR.min_depth = 0

    def oC_XorExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_XorExpression', parent=parent)) as current:
            self.oC_AndExpression(parent=current)
            if self._max_depth >= 12:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    self.XOR(parent=current)
                    self.SP(parent=current)
                    self.oC_AndExpression(parent=current)
            return current
    oC_XorExpression.min_depth = 12

    def XOR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='XOR', parent=parent)) as current:
            UnlexerRule(src='X', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='R', parent=current)
            return current
    XOR.min_depth = 0

    def oC_AndExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_AndExpression', parent=parent)) as current:
            self.oC_NotExpression(parent=current)
            if self._max_depth >= 11:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    self.AND(parent=current)
                    self.SP(parent=current)
                    self.oC_NotExpression(parent=current)
            return current
    oC_AndExpression.min_depth = 11

    def AND(self, parent=None):
        with RuleContext(self, UnlexerRule(name='AND', parent=parent)) as current:
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='D', parent=current)
            return current
    AND.min_depth = 0

    def oC_NotExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_NotExpression', parent=parent)) as current:
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.NOT(parent=current)
                    self.SP(parent=current)
            self.oC_ComparisonExpression(parent=current)
            return current
    oC_NotExpression.min_depth = 10

    def NOT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NOT', parent=parent)) as current:
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='T', parent=current)
            return current
    NOT.min_depth = 0

    def oC_ComparisonExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ComparisonExpression', parent=parent)) as current:
            self.oC_AddOrSubtractExpression(parent=current)
            if self._max_depth >= 10:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    self.oC_PartialComparisonExpression(parent=current)
            return current
    oC_ComparisonExpression.min_depth = 9

    def oC_AddOrSubtractExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_AddOrSubtractExpression', parent=parent)) as current:
            self.oC_MultiplyDivideModuloExpression(parent=current)
            if self._max_depth >= 8:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [8, 8], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            self.SP(parent=current)
                            UnlexerRule(src='+', parent=current)
                            self.SP(parent=current)
                            self.oC_MultiplyDivideModuloExpression(parent=current)
                        elif choice0 == 1:
                            self.SP(parent=current)
                            UnlexerRule(src='-', parent=current)
                            self.SP(parent=current)
                            self.oC_MultiplyDivideModuloExpression(parent=current)
            return current
    oC_AddOrSubtractExpression.min_depth = 8

    def oC_MultiplyDivideModuloExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_MultiplyDivideModuloExpression', parent=parent)) as current:
            self.oC_PowerOfExpression(parent=current)
            if self._max_depth >= 7:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [7, 7, 7], [1, 1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            self.SP(parent=current)
                            UnlexerRule(src='*', parent=current)
                            self.SP(parent=current)
                            self.oC_PowerOfExpression(parent=current)
                        elif choice0 == 1:
                            self.SP(parent=current)
                            UnlexerRule(src='/', parent=current)
                            self.SP(parent=current)
                            self.oC_PowerOfExpression(parent=current)
                        elif choice0 == 2:
                            self.SP(parent=current)
                            UnlexerRule(src='%', parent=current)
                            self.SP(parent=current)
                            self.oC_PowerOfExpression(parent=current)
            return current
    oC_MultiplyDivideModuloExpression.min_depth = 7

    def oC_PowerOfExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PowerOfExpression', parent=parent)) as current:
            self.oC_UnaryAddOrSubtractExpression(parent=current)
            if self._max_depth >= 6:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.SP(parent=current)
                    UnlexerRule(src='^', parent=current)
                    self.SP(parent=current)
                    self.oC_UnaryAddOrSubtractExpression(parent=current)
            return current
    oC_PowerOfExpression.min_depth = 6

    def oC_UnaryAddOrSubtractExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_UnaryAddOrSubtractExpression', parent=parent)) as current:
            self.oC_StringListNullOperatorExpression(parent=current)
            return current
    oC_UnaryAddOrSubtractExpression.min_depth = 5

    def oC_StringListNullOperatorExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_StringListNullOperatorExpression', parent=parent)) as current:
            self.oC_PropertyOrLabelsExpression(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [5, 5, 4], [1, 1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        [self.oC_StringOperatorExpression, self.oC_ListOperatorExpression, self.oC_NullOperatorExpression][choice0](parent=current)
            return current
    oC_StringListNullOperatorExpression.min_depth = 4

    def oC_ListOperatorExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ListOperatorExpression', parent=parent)) as current:
            with AlternationContext(self, [4, 4], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.SP(parent=current)
                    self.IN(parent=current)
                    self.SP(parent=current)
                    self.oC_PropertyOrLabelsExpression(parent=current)
                elif choice0 == 1:
                    self.SP(parent=current)
                    UnlexerRule(src='[', parent=current)
                    self.rG_Expression(parent=current)
                    UnlexerRule(src=']', parent=current)
            return current
    oC_ListOperatorExpression.min_depth = 4

    def IN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='IN', parent=parent)) as current:
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='N', parent=current)
            return current
    IN.min_depth = 0

    def oC_StringOperatorExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_StringOperatorExpression', parent=parent)) as current:
            with AlternationContext(self, [3, 3, 3], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.SP(parent=current)
                    self.STARTS(parent=current)
                    self.SP(parent=current)
                    self.WITH(parent=current)
                elif choice0 == 1:
                    self.SP(parent=current)
                    self.ENDS(parent=current)
                    self.SP(parent=current)
                    self.WITH(parent=current)
                elif choice0 == 2:
                    self.SP(parent=current)
                    self.CONTAINS(parent=current)
            self.SP(parent=current)
            self.oC_PropertyOrLabelsExpression(parent=current)
            return current
    oC_StringOperatorExpression.min_depth = 4

    def STARTS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='STARTS', parent=parent)) as current:
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='S', parent=current)
            return current
    STARTS.min_depth = 0

    def ENDS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ENDS', parent=parent)) as current:
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='S', parent=current)
            return current
    ENDS.min_depth = 0

    def CONTAINS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CONTAINS', parent=parent)) as current:
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='S', parent=current)
            return current
    CONTAINS.min_depth = 0

    def oC_NullOperatorExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_NullOperatorExpression', parent=parent)) as current:
            with AlternationContext(self, [3, 3], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.SP(parent=current)
                    self.IS(parent=current)
                    self.SP(parent=current)
                    self.NULL(parent=current)
                elif choice0 == 1:
                    self.SP(parent=current)
                    self.IS(parent=current)
                    self.SP(parent=current)
                    self.NOT(parent=current)
                    self.SP(parent=current)
                    self.NULL(parent=current)
            return current
    oC_NullOperatorExpression.min_depth = 3

    def IS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='IS', parent=parent)) as current:
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='S', parent=current)
            return current
    IS.min_depth = 0

    def NULL(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NULL', parent=parent)) as current:
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='L', parent=current)
            return current
    NULL.min_depth = 0

    def oC_PropertyOrLabelsExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PropertyOrLabelsExpression', parent=parent)) as current:
            self.oC_Atom(parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.oC_PropertyLookup(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_NodeLabels(parent=current)
            return current
    oC_PropertyOrLabelsExpression.min_depth = 3

    def oC_Atom(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Atom', parent=parent)) as current:
            with AlternationContext(self, [2, 3, 6, 3, 7, 16, 4, 5, 4], [1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.oC_Literal(parent=current)
                elif choice0 == 1:
                    self.oC_Parameter(parent=current)
                elif choice0 == 2:
                    self.oC_CaseExpression(parent=current)
                elif choice0 == 3:
                    self.COUNT(parent=current)
                    UnlexerRule(src='(', parent=current)
                    self.SP(parent=current)
                    UnlexerRule(src='*', parent=current)
                    self.SP(parent=current)
                    UnlexerRule(src=')', parent=current)
                elif choice0 == 4:
                    self.oC_ListComprehension(parent=current)
                elif choice0 == 5:
                    self.oC_PatternComprehension(parent=current)
                elif choice0 == 6:
                    self.oC_RelationshipsPattern(parent=current)
                elif choice0 == 7:
                    self.oC_FunctionInvocation(parent=current)
                elif choice0 == 8:
                    self.oC_Variable(parent=current)
            return current
    oC_Atom.min_depth = 2

    def COUNT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COUNT', parent=parent)) as current:
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='T', parent=current)
            return current
    COUNT.min_depth = 0

    def ANY(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ANY', parent=parent)) as current:
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='Y', parent=current)
            return current
    ANY.min_depth = 0

    def NONE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NONE', parent=parent)) as current:
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    NONE.min_depth = 0

    def SINGLE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SINGLE', parent=parent)) as current:
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='G', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    SINGLE.min_depth = 0

    def oC_Literal(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Literal', parent=parent)) as current:
            with AlternationContext(self, [4, 1, 2, 1, 1, 4], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.oC_NumberLiteral, self.StringLiteral, self.oC_BooleanLiteral, self.NULL, self.oC_MapLiteral, self.oC_ListLiteral][choice0](parent=current)
            return current
    oC_Literal.min_depth = 1

    def oC_BooleanLiteral(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_BooleanLiteral', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.TRUE, self.FALSE][choice0](parent=current)
            return current
    oC_BooleanLiteral.min_depth = 1

    def TRUE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='TRUE', parent=parent)) as current:
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    TRUE.min_depth = 0

    def FALSE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FALSE', parent=parent)) as current:
            UnlexerRule(src='F', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    FALSE.min_depth = 0

    def oC_ListLiteral(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ListLiteral', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            self.SP(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.rG_Expression(parent=current)
                    self.SP(parent=current)
                    if self._max_depth >= 4:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            UnlexerRule(src=',', parent=current)
                            self.SP(parent=current)
                            self.rG_Expression(parent=current)
                            self.SP(parent=current)
            UnlexerRule(src=']', parent=current)
            return current
    oC_ListLiteral.min_depth = 3

    def oC_PartialComparisonExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PartialComparisonExpression', parent=parent)) as current:
            with AlternationContext(self, [9, 9, 9, 9, 9, 9], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='=', parent=current)
                    self.SP(parent=current)
                    self.oC_AddOrSubtractExpression(parent=current)
                elif choice0 == 1:
                    UnlexerRule(src='<>', parent=current)
                    self.SP(parent=current)
                    self.oC_AddOrSubtractExpression(parent=current)
                elif choice0 == 2:
                    UnlexerRule(src='<', parent=current)
                    self.SP(parent=current)
                    self.oC_AddOrSubtractExpression(parent=current)
                elif choice0 == 3:
                    UnlexerRule(src='>', parent=current)
                    self.SP(parent=current)
                    self.oC_AddOrSubtractExpression(parent=current)
                elif choice0 == 4:
                    UnlexerRule(src='<=', parent=current)
                    self.SP(parent=current)
                    self.oC_AddOrSubtractExpression(parent=current)
                elif choice0 == 5:
                    UnlexerRule(src='>=', parent=current)
                    self.SP(parent=current)
                    self.oC_AddOrSubtractExpression(parent=current)
            return current
    oC_PartialComparisonExpression.min_depth = 9

    def oC_RelationshipsPattern(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RelationshipsPattern', parent=parent)) as current:
            self.oC_NodePattern(parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.SP(parent=current)
                    self.oC_PatternElementChain(parent=current)
            return current
    oC_RelationshipsPattern.min_depth = 3

    def oC_FilterExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_FilterExpression', parent=parent)) as current:
            self.oC_IdInColl(parent=current)
            if self._max_depth >= 16:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    self.oC_Where(parent=current)
            return current
    oC_FilterExpression.min_depth = 5

    def oC_IdInColl(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_IdInColl', parent=parent)) as current:
            self.oC_Variable(parent=current)
            self.SP(parent=current)
            self.IN(parent=current)
            self.SP(parent=current)
            self.oC_PropertyOrLabelsExpression(parent=current)
            return current
    oC_IdInColl.min_depth = 4

    def oC_FunctionInvocation(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_FunctionInvocation', parent=parent)) as current:
            self.oC_FunctionName(parent=current)
            UnlexerRule(src='(', parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.DISTINCT(parent=current)
                    self.SP(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.rG_Expression(parent=current)
                    self.SP(parent=current)
                    if self._max_depth >= 4:
                        for _ in self._model.quantify(current, 2, min=0, max=inf):
                            UnlexerRule(src=',', parent=current)
                            self.SP(parent=current)
                            self.rG_Expression(parent=current)
                            self.SP(parent=current)
            UnlexerRule(src=')', parent=current)
            return current
    oC_FunctionInvocation.min_depth = 4

    def oC_FunctionName(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_FunctionName', parent=parent)) as current:
            self.oC_SymbolicName(parent=current)
            return current
    oC_FunctionName.min_depth = 3

    def oC_ExplicitProcedureInvocation(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ExplicitProcedureInvocation', parent=parent)) as current:
            self.oC_ProcedureName(parent=current)
            UnlexerRule(src='(', parent=current)
            self.SP(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.rG_Expression(parent=current)
                    self.SP(parent=current)
                    if self._max_depth >= 4:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            UnlexerRule(src=',', parent=current)
                            self.SP(parent=current)
                            self.rG_Expression(parent=current)
                            self.SP(parent=current)
            UnlexerRule(src=')', parent=current)
            return current
    oC_ExplicitProcedureInvocation.min_depth = 3

    def oC_ImplicitProcedureInvocation(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ImplicitProcedureInvocation', parent=parent)) as current:
            self.oC_ProcedureName(parent=current)
            return current
    oC_ImplicitProcedureInvocation.min_depth = 1

    def oC_ProcedureResultField(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ProcedureResultField', parent=parent)) as current:
            self.oC_SymbolicName(parent=current)
            return current
    oC_ProcedureResultField.min_depth = 3

    def oC_ProcedureName(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ProcedureName', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['algo.bfs', 'algo.pagerank', 'db.idx.fulltext.createnodeindex', 'db.idx.fulltext.drop', 'db.idx.fulltext.querynodes', 'db.labels', 'db.propertykeys', 'db.relationshiptypes', 'dbms.procedures'][choice0], parent=current)
            return current
    oC_ProcedureName.min_depth = 0

    def oC_ListComprehension(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ListComprehension', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            self.SP(parent=current)
            self.oC_FilterExpression(parent=current)
            if self._max_depth >= 15:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SP(parent=current)
                    UnlexerRule(src='|', parent=current)
                    self.SP(parent=current)
                    self.oC_Expression(parent=current)
            self.SP(parent=current)
            UnlexerRule(src=']', parent=current)
            return current
    oC_ListComprehension.min_depth = 6

    def oC_PatternComprehension(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PatternComprehension', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            self.SP(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.oC_Variable(parent=current)
                    self.SP(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.SP(parent=current)
            self.oC_RelationshipsPattern(parent=current)
            self.SP(parent=current)
            if self._max_depth >= 15:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.WHERE(parent=current)
                    self.SP(parent=current)
                    self.oC_Expression(parent=current)
                    self.SP(parent=current)
            UnlexerRule(src='|', parent=current)
            self.SP(parent=current)
            self.oC_Expression(parent=current)
            self.SP(parent=current)
            UnlexerRule(src=']', parent=current)
            return current
    oC_PatternComprehension.min_depth = 15

    def oC_PropertyLookup(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PropertyLookup', parent=parent)) as current:
            UnlexerRule(src='.', parent=current)
            self.oC_PropertyKeyName(parent=current)
            return current
    oC_PropertyLookup.min_depth = 2

    def oC_CaseExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_CaseExpression', parent=parent)) as current:
            with AlternationContext(self, [5, 5], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.CASE(parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=1, max=inf):
                            self.SP(parent=current)
                            self.oC_CaseAlternatives(parent=current)
                elif choice0 == 1:
                    self.CASE(parent=current)
                    self.SP(parent=current)
                    self.rG_Expression(parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 1, min=1, max=inf):
                            self.SP(parent=current)
                            self.oC_CaseAlternatives(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 2, min=0, max=1):
                    self.SP(parent=current)
                    self.ELSE(parent=current)
                    self.SP(parent=current)
                    self.rG_Expression(parent=current)
            self.SP(parent=current)
            self.END(parent=current)
            return current
    oC_CaseExpression.min_depth = 5

    def CASE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CASE', parent=parent)) as current:
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    CASE.min_depth = 0

    def ELSE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ELSE', parent=parent)) as current:
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    ELSE.min_depth = 0

    def END(self, parent=None):
        with RuleContext(self, UnlexerRule(name='END', parent=parent)) as current:
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='D', parent=current)
            return current
    END.min_depth = 0

    def oC_CaseAlternatives(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_CaseAlternatives', parent=parent)) as current:
            self.WHEN(parent=current)
            self.SP(parent=current)
            self.rG_Expression(parent=current)
            self.SP(parent=current)
            self.THEN(parent=current)
            self.SP(parent=current)
            self.rG_Expression(parent=current)
            return current
    oC_CaseAlternatives.min_depth = 4

    def WHEN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WHEN', parent=parent)) as current:
            UnlexerRule(src='W', parent=current)
            UnlexerRule(src='H', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='N', parent=current)
            return current
    WHEN.min_depth = 0

    def THEN(self, parent=None):
        with RuleContext(self, UnlexerRule(name='THEN', parent=parent)) as current:
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='H', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='N', parent=current)
            return current
    THEN.min_depth = 0

    def oC_Variable(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Variable', parent=parent)) as current:
            self.oC_SymbolicName(parent=current)
            return current
    oC_Variable.min_depth = 3

    def StringLiteral(self, parent=None):
        with RuleContext(self, UnlexerRule(name='StringLiteral', parent=parent)) as current:
            UnlexerRule(src='"', parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.StringLiteral_0(parent=current)
            UnlexerRule(src='"', parent=current)
            return current
    StringLiteral.min_depth = 0

    def oC_NumberLiteral(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_NumberLiteral', parent=parent)) as current:
            with AlternationContext(self, [4, 3], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.oC_DoubleLiteral, self.oC_IntegerLiteral][choice0](parent=current)
            return current
    oC_NumberLiteral.min_depth = 3

    def oC_MapLiteral(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_MapLiteral', parent=parent)) as current:
            UnlexerRule(src='{', parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.oC_PropertyKeyName(parent=current)
                    UnlexerRule(src=':', parent=current)
                    self.rG_Expression(parent=current)
                    if self._max_depth >= 4:
                        for _ in self._model.quantify(current, 1, min=0, max=inf):
                            UnlexerRule(src=',', parent=current)
                            self.oC_PropertyKeyName(parent=current)
                            UnlexerRule(src=':', parent=current)
                            self.rG_Expression(parent=current)
            UnlexerRule(src='}', parent=current)
            return current
    oC_MapLiteral.min_depth = 0

    def oC_Parameter(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Parameter', parent=parent)) as current:
            UnlexerRule(src='$', parent=current)
            with AlternationContext(self, [3, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.oC_SymbolicName, self.DecimalInteger][choice0](parent=current)
            return current
    oC_Parameter.min_depth = 2

    def oC_PropertyExpression(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PropertyExpression', parent=parent)) as current:
            self.oC_Variable(parent=current)
            self.oC_PropertyLookup(parent=current)
            return current
    oC_PropertyExpression.min_depth = 4

    def oC_PropertyKeyName(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_PropertyKeyName', parent=parent)) as current:
            UnlexerRule(src='prop', parent=current)
            self.NonZeroDigit(parent=current)
            return current
    oC_PropertyKeyName.min_depth = 1

    def oC_IntegerLiteral(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_IntegerLiteral', parent=parent)) as current:
            with AlternationContext(self, [3, 3, 2], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.HexInteger, self.OctalInteger, self.DecimalInteger][choice0](parent=current)
            return current
    oC_IntegerLiteral.min_depth = 2

    def HexInteger(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HexInteger', parent=parent)) as current:
            UnlexerRule(src='0x', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.HexDigit(parent=current)
            return current
    HexInteger.min_depth = 2

    def DecimalInteger(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DecimalInteger', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.ZeroDigit(parent=current)
                elif choice0 == 1:
                    self.NonZeroDigit(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 0, min=0, max=inf):
                            self.Digit(parent=current)
            return current
    DecimalInteger.min_depth = 1

    def OctalInteger(self, parent=None):
        with RuleContext(self, UnlexerRule(name='OctalInteger', parent=parent)) as current:
            self.ZeroDigit(parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.OctDigit(parent=current)
            return current
    OctalInteger.min_depth = 2

    def HexLetter(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HexLetter', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['A', 'B', 'C', 'D', 'E', 'F'][choice0], parent=current)
            return current
    HexLetter.min_depth = 0

    def HexDigit(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HexDigit', parent=parent)) as current:
            with AlternationContext(self, [2, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.Digit, self.HexLetter][choice0](parent=current)
            return current
    HexDigit.min_depth = 1

    def Digit(self, parent=None):
        with RuleContext(self, UnlexerRule(name='Digit', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.ZeroDigit, self.NonZeroDigit][choice0](parent=current)
            return current
    Digit.min_depth = 1

    def NonZeroDigit(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NonZeroDigit', parent=parent)) as current:
            with AlternationContext(self, [1, 0, 0], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                src = [None, '8', '9'][choice0]
                rule = [self.NonZeroOctDigit, None, None][choice0]
                if src is not None:
                    UnlexerRule(src=src, parent=current)
                else:
                    rule(parent=current)
            return current
    NonZeroDigit.min_depth = 0

    def NonZeroOctDigit(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NonZeroOctDigit', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['1', '2', '3', '4', '5', '6', '7'][choice0], parent=current)
            return current
    NonZeroOctDigit.min_depth = 0

    def OctDigit(self, parent=None):
        with RuleContext(self, UnlexerRule(name='OctDigit', parent=parent)) as current:
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.ZeroDigit, self.NonZeroOctDigit][choice0](parent=current)
            return current
    OctDigit.min_depth = 1

    def ZeroDigit(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ZeroDigit', parent=parent)) as current:
            UnlexerRule(src='0', parent=current)
            return current
    ZeroDigit.min_depth = 0

    def oC_DoubleLiteral(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_DoubleLiteral', parent=parent)) as current:
            with AlternationContext(self, [3, 3], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.ExponentDecimalReal, self.RegularDecimalReal][choice0](parent=current)
            return current
    oC_DoubleLiteral.min_depth = 3

    def ExponentDecimalReal(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ExponentDecimalReal', parent=parent)) as current:
            with AlternationContext(self, [2, 2, 2], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 0, min=1, max=inf):
                            self.Digit(parent=current)
                elif choice0 == 1:
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 1, min=1, max=inf):
                            self.Digit(parent=current)
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 2, min=1, max=inf):
                            self.Digit(parent=current)
                elif choice0 == 2:
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 3, min=1, max=inf):
                            self.Digit(parent=current)
            UnlexerRule(src='E', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 4, min=0, max=1):
                    UnlexerRule(src='-', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 5, min=1, max=inf):
                    self.Digit(parent=current)
            return current
    ExponentDecimalReal.min_depth = 2

    def RegularDecimalReal(self, parent=None):
        with RuleContext(self, UnlexerRule(name='RegularDecimalReal', parent=parent)) as current:
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.Digit(parent=current)
            UnlexerRule(src='.', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=1, max=inf):
                    self.Digit(parent=current)
            return current
    RegularDecimalReal.min_depth = 2

    def oC_ReservedWord(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_ReservedWord', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.ALL, self.ASC, self.ASCENDING, self.BY, self.CREATE, self.DELETE, self.DESC, self.DESCENDING, self.DETACH, self.LIMIT, self.MATCH, self.MERGE, self.ON, self.OPTIONAL, self.ORDER, self.RETURN, self.SET, self.L_SKIP, self.WHERE, self.WITH, self.UNION, self.UNWIND, self.AND, self.AS, self.CONTAINS, self.DISTINCT, self.ENDS, self.IN, self.IS, self.NOT, self.OR, self.STARTS, self.XOR, self.FALSE, self.TRUE, self.NULL, self.CONSTRAINT, self.DO, self.FOR, self.REQUIRE, self.UNIQUE, self.CASE, self.WHEN, self.THEN, self.ELSE, self.END, self.MANDATORY, self.SCALAR, self.OF, self.ADD, self.DROP][choice0](parent=current)
            return current
    oC_ReservedWord.min_depth = 1

    def CONSTRAINT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='CONSTRAINT', parent=parent)) as current:
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='T', parent=current)
            return current
    CONSTRAINT.min_depth = 0

    def DO(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DO', parent=parent)) as current:
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='O', parent=current)
            return current
    DO.min_depth = 0

    def FOR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='FOR', parent=parent)) as current:
            UnlexerRule(src='F', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='R', parent=current)
            return current
    FOR.min_depth = 0

    def REQUIRE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='REQUIRE', parent=parent)) as current:
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='E', parent=current)
            UnlexerRule(src='Q', parent=current)
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    REQUIRE.min_depth = 0

    def UNIQUE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='UNIQUE', parent=parent)) as current:
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='Q', parent=current)
            UnlexerRule(src='U', parent=current)
            UnlexerRule(src='E', parent=current)
            return current
    UNIQUE.min_depth = 0

    def MANDATORY(self, parent=None):
        with RuleContext(self, UnlexerRule(name='MANDATORY', parent=parent)) as current:
            UnlexerRule(src='M', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='N', parent=current)
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='T', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='Y', parent=current)
            return current
    MANDATORY.min_depth = 0

    def SCALAR(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SCALAR', parent=parent)) as current:
            UnlexerRule(src='S', parent=current)
            UnlexerRule(src='C', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='R', parent=current)
            return current
    SCALAR.min_depth = 0

    def OF(self, parent=None):
        with RuleContext(self, UnlexerRule(name='OF', parent=parent)) as current:
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='F', parent=current)
            return current
    OF.min_depth = 0

    def ADD(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ADD', parent=parent)) as current:
            UnlexerRule(src='A', parent=current)
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='D', parent=current)
            return current
    ADD.min_depth = 0

    def DROP(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DROP', parent=parent)) as current:
            UnlexerRule(src='D', parent=current)
            UnlexerRule(src='R', parent=current)
            UnlexerRule(src='O', parent=current)
            UnlexerRule(src='P', parent=current)
            return current
    DROP.min_depth = 0

    def oC_SymbolicName(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_SymbolicName', parent=parent)) as current:
            self.EscapedSymbolicName(parent=current)
            return current
    oC_SymbolicName.min_depth = 2

    def EscapedSymbolicName(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EscapedSymbolicName', parent=parent)) as current:
            self.EscapedSymbolicName_0(parent=current)
            return current
    EscapedSymbolicName.min_depth = 1

    def SP(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SP', parent=parent)) as current:
            self.WHITESPACE(parent=current)
            return current
    SP.min_depth = 2

    def WHITESPACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WHITESPACE', parent=parent)) as current:
            self.SPACE(parent=current)
            return current
    WHITESPACE.min_depth = 1

    def oC_LeftArrowHead(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_LeftArrowHead', parent=parent)) as current:
            UnlexerRule(src='<', parent=current)
            return current
    oC_LeftArrowHead.min_depth = 0

    def oC_RightArrowHead(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_RightArrowHead', parent=parent)) as current:
            UnlexerRule(src='>', parent=current)
            return current
    oC_RightArrowHead.min_depth = 0

    def oC_Dash(self, parent=None):
        with RuleContext(self, UnparserRule(name='oC_Dash', parent=parent)) as current:
            UnlexerRule(src='-', parent=current)
            return current
    oC_Dash.min_depth = 0

    def EscapedSymbolicName_0(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EscapedSymbolicName_0', parent=parent)) as current:
            UnlexerRule(src='var', parent=current)
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
            return current
    EscapedSymbolicName_0.min_depth = 0

    def SPACE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SPACE', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[2]), parent=current)
            return current
    SPACE.min_depth = 0

    def StringLiteral_0(self, parent=None):
        with RuleContext(self, UnlexerRule(name='StringLiteral_0', parent=parent)) as current:
            UnlexerRule(src='L', parent=current)
            UnlexerRule(src='I', parent=current)
            UnlexerRule(src='T', parent=current)
            return current
    StringLiteral_0.min_depth = 0

    _default_rule = oC_Cypher

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(49, 58)])),
        2: list(itertools.chain.from_iterable([range(32, 33)])),
    }
